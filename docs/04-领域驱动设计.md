# 业务域拆分目录结构与分层规范

## 目录结构规划

### 1. 按业务域拆分的目录结构

```
src/
├── domains/                    # 业务域目录
│   ├── auth/                  # 认证域
│   │   ├── components/        # 认证相关组件
│   │   ├── composables/       # 认证相关组合式函数
│   │   ├── stores/            # 认证相关状态管理
│   │   ├── services/          # 认证相关API服务
│   │   ├── types/             # 认证相关类型定义
│   │   └── index.ts           # 导出入口
│   ├── user/                  # 用户域
│   │   ├── components/
│   │   ├── composables/
│   │   ├── stores/
│   │   ├── services/
│   │   ├── types/
│   │   └── index.ts
│   ├── system/                # 系统管理域
│   │   ├── components/
│   │   ├── composables/
│   │   ├── stores/
│   │   ├── services/
│   │   ├── types/
│   │   └── index.ts
│   └── [其他业务域]/
├── shared/                    # 共享资源
│   ├── components/            # 共享组件
│   ├── composables/           # 共享组合式函数
│   ├── stores/                # 共享状态管理
│   ├── services/              # 共享服务
│   ├── utils/                 # 工具函数
│   ├── types/                 # 共享类型定义
│   └── constants/             # 常量定义
├── infrastructure/            # 基础设施
│   ├── api/                   # API基础配置
│   ├── router/                # 路由配置
│   ├── storage/               # 存储相关
│   ├── error/                 # 错误处理
│   └── logging/               # 日志系统
└── ui/                        # UI组件库
    ├── components/            # 基础UI组件
    ├── themes/                # 主题配置
    └── styles/                # 全局样式
```

### 2. 分层规范

#### 2.1 表现层 (Presentation Layer)
- **位置**: `domains/[domain]/components/`
- **职责**: 负责UI展示和用户交互
- **原则**: 
  - 组件应保持纯净，只关注UI展示
  - 业务逻辑通过composables注入
  - 状态管理通过stores注入

#### 2.2 业务逻辑层 (Business Logic Layer)
- **位置**: `domains/[domain]/composables/`
- **职责**: 处理业务逻辑和状态转换
- **原则**:
  - 封装业务规则和计算逻辑
  - 调用服务层进行数据操作
  - 不直接操作DOM

#### 2.3 数据访问层 (Data Access Layer)
- **位置**: `domains/[domain]/services/`
- **职责**: 负责与外部API交互
- **原则**:
  - 封装API调用逻辑
  - 处理数据转换和错误处理
  - 不包含业务逻辑

#### 2.4 状态管理层 (State Management Layer)
- **位置**: `domains/[domain]/stores/`
- **职责**: 管理域内状态
- **原则**:
  - 按业务域划分状态
  - 避免跨域直接状态访问
  - 通过事件或服务进行域间通信

### 3. 组件分层规范

#### 3.1 基础组件 (Base Components)
- **位置**: `ui/components/`
- **特点**: 无业务逻辑，可复用的UI原子组件
- **示例**: Button, Input, Modal等

#### 3.2 业务组件 (Business Components)
- **位置**: `domains/[domain]/components/`
- **特点**: 包含特定业务逻辑的组件
- **示例**: LoginForm, UserProfile等

#### 3.3 页面组件 (Page Components)
- **位置**: `views/[domain]/`
- **特点**: 组合多个业务组件形成完整页面
- **原则**: 只做组件组合和数据传递，不包含复杂业务逻辑

### 4. 状态管理规范

#### 4.1 域内状态
- 使用Pinia进行状态管理
- 按业务域划分store模块
- 状态变更通过actions进行

#### 4.2 跨域状态
- 通过共享store或事件总线进行
- 避免直接跨域状态访问
- 使用依赖注入模式解耦

### 5. 命名规范

#### 5.1 文件命名
- 组件文件: PascalCase (UserProfile.vue)
- 服务文件: camelCase (userService.ts)
- 类型文件: camelCase (userTypes.ts)
- 常量文件: UPPER_SNAKE_CASE (API_CONSTANTS.ts)

#### 5.2 导出规范
- 每个域提供统一的导出入口 (index.ts)
- 使用命名导出而非默认导出
- 提供清晰的类型导出

### 6. 依赖原则

#### 6.1 依赖方向
- 上层可以依赖下层，反之不行
- 业务域之间通过服务层交互
- 避免循环依赖

#### 6.2 共享资源
- 通用组件放在shared目录
- 工具函数按功能分类
- 常量统一管理

### 7. 迁移策略

#### 7.1 渐进式迁移
1. 创建新的目录结构
2. 逐个模块迁移
3. 保持向后兼容
4. 完成后清理旧代码

#### 7.2 迁移顺序
1. 基础设施层
2. 共享资源层
3. UI组件库
4. 业务域（按优先级）

## 实施指南

### 1. 创建域结构
```bash
# 创建认证域
mkdir -p src/domains/auth/{components,composables,stores,services,types}
touch src/domains/auth/index.ts
```

### 2. 定义域接口
```typescript
// src/domains/auth/types/index.ts
export interface AuthState {
  isAuthenticated: boolean;
  user: User | null;
  token: string | null;
}

export interface AuthService {
  login(credentials: LoginCredentials): Promise<AuthResult>;
  logout(): Promise<void>;
  refreshToken(): Promise<string>;
}
```

### 3. 实现域服务
```typescript
// src/domains/auth/services/authService.ts
import { AuthService } from '../types';

export const authService: AuthService = {
  async login(credentials) {
    // 实现登录逻辑
  },
  async logout() {
    // 实现登出逻辑
  },
  async refreshToken() {
    // 实现刷新令牌逻辑
  }
};
```

### 4. 创建域状态
```typescript
// src/domains/auth/stores/authStore.ts
import { defineStore } from 'pinia';
import { AuthState } from '../types';
import { authService } from '../services/authService';

export const useAuthStore = defineStore('auth', {
  state: (): AuthState => ({
    isAuthenticated: false,
    user: null,
    token: null,
  }),
  actions: {
    async login(credentials) {
      const result = await authService.login(credentials);
      this.isAuthenticated = true;
      this.user = result.user;
      this.token = result.token;
    },
    async logout() {
      await authService.logout();
      this.isAuthenticated = false;
      this.user = null;
      this.token = null;
    },
  },
});
```

### 5. 创建域组件
```vue
<!-- src/domains/auth/components/LoginForm.vue -->
<template>
  <form @submit.prevent="handleLogin">
    <!-- 登录表单UI -->
  </form>
</template>

<script setup lang="ts">
import { useAuthStore } from '../stores/authStore';

const authStore = useAuthStore();

const handleLogin = async (credentials: LoginCredentials) => {
  await authStore.login(credentials);
};
</script>
```

### 6. 导出域接口
```typescript
// src/domains/auth/index.ts
export * from './types';
export { authService } from './services/authService';
export { useAuthStore } from './stores/authStore';
export { default as LoginForm } from './components/LoginForm.vue';
```

## 最佳实践

1. **单一职责**: 每个模块只负责一个明确的业务领域
2. **低耦合高内聚**: 域内组件高度内聚，域间低耦合
3. **依赖倒置**: 高层模块不依赖低层模块，都依赖抽象
4. **接口隔离**: 使用小而专一的接口
5. **开闭原则**: 对扩展开放，对修改关闭